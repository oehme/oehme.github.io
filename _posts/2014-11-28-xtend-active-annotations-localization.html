---
layout: post
title: ! 'Xtend - Active Annotations : Localization'
date: '2014-11-28T16:26:00.004+01:00'
author: Stefan Oehme
tags:
- xtend series
modified_time: '2014-11-28T16:26:44.700+01:00'
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-9052464814234503642
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2014/11/xtend-active-annotations-localization.html
---

<a href="{{site.baseUrl}}/2014/11/25/xtend-active-annotations-part-2.html">Last time</a> we took our first steps at implementing <a href="http://xtend-lang.org/">Xtend</a> Annotation Processors. We did some simple modifications to the Java AST. This time we want to automate a much more involving pattern: Localization and ResourceBundles.<br /><div><br /></div><div>In Java you usually use .properties files to supply localized Strings for the UI. The ResourceBundle API allows you to access them in an untyped way using String constants. If you want more convenience, you need a static facade like this:</div><div><br /></div><script src="https://gist.github.com/oehme/1c4d9f2d24e41450c59f.js"></script><script src="https://gist.github.com/oehme/a00c6a2745ea25adcdc0.js"></script><br /><div>Writing this by hand gets tedious quickly, so many IDEs come with a wizard that generates this code for you. But you still need to manually trigger the generator and check that code into version control. Wouldn't it be cool if this statically typed facade was automatically generated and updated based on the property file?</div><div><br /></div><div>That's exactly what the @Messages annotation does. The full source code is available on <a href="https://github.com/oehme/xtend-contrib/blob/master/xtend-contrib/src/main/java/de/oehme/xtend/contrib/localization/Messages.xtend">Github</a>.&nbsp;There are many parts that you will easily understand with your knowledge from the previous post. For instance, the annotation adds a field to hold the ResourceBundle, a constructor that takes a Locale etc. The interesting part is where we actually read in the property file at compile time:</div><div><br /></div><script src="https://gist.github.com/oehme/84f56a72cf9d3413aee0.js"></script> <br /><div>We use the Path API to find the physical location of the current class and get the property file of the same name. We give the user a good error message when we cannot find the file and just stop processing in that case.</div><div><br /></div><div>Then we iterate over all messages in that property file and create a method for each. The name is converted from underscore to camelcase naming convention. For each pattern variable we create a method argument. By looking at the type of the pattern variables, we can also make some deductions about the type of the method arguments. For instance, if a pattern uses a NumberFormat, then only Numbers can possibly be passed to it. Again, we use Xtend's awesome <a href="http://mnmlst-dvlpr.blogspot.de/2014/10/xtend-perfect-for-code-generation.html">template expressions</a> to generate the body of the method.</div><div><br /></div><script src="https://gist.github.com/oehme/6fba9907ea5e8a7f1192.js"></script><script src="https://gist.github.com/oehme/9de2d854f53dff2cc411.js"></script><br /><div>With this in place, we now just add the @Messages annotation to an otherwise empty class that has the same name as our property file. All the static facade is automatically generated and available in content assist, outline, validation etc. You can even use existing Java tools like <a href="http://www.ucdetector.org/">UCDetector</a>&nbsp;to find messages that are no longer used. And every time you edit the property file later on, the Java code will be regenerated automatically!</div><div><br /></div><script src="https://gist.github.com/oehme/297bd5e2ad74f8ddbbe0.js"></script> There are many other untyped files that can benefit from a static facade to Java. Sven Efftinge wrote&nbsp;the <a href="https://github.com/svenefftinge/jsonized">@Jsonized</a> annotation&nbsp;that takes some example JSON input and generates a Java class hierarchy from that. Toby Kurien maintains the <a href="https://github.com/tobykurien/Xtendroid">Xtendroid</a> project that parses the Android UI descriptor and automatically generates accessors for each UI element. Anton Kosyakov automated the creation of <a href="https://github.com/akosyakov/xtend-gwt-clientbundle">GWT ClientBundles and CSSResources</a>.<br /><br />What pattern would you automate? Try it out and tell your story in the <a href="https://groups.google.com/forum/#!forum/xtend-lang">forum</a> =)