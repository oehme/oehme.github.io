---
layout: post
title: Xtend - Perfect for Code generation
date: '2014-10-24T20:49:00.000+02:00'
author: Stefan Oehme
tags:
- xtend series
modified_time: '2014-10-24T21:00:37.342+02:00'
thumbnail: http://3.bp.blogspot.com/-27K49EC2dHU/VEqaoYt3luI/AAAAAAAAO-g/2fFOyg-S02w/s72-c/greet.PNG
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-2630971293819910343
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2014/10/xtend-perfect-for-code-generation.html
---

Before Xtend became a general purpose language, it was designed for building code generators and model-to-model transformations in the <a href="https://www.eclipse.org/Xtext/">Xtext </a>framework. And even though this is no longer Xtend's main focus, the related features are useful in other situations, too!<br /><br /><h3>Template Expressions</h3><br />Pretty much every modern language has some way to insert variables into a String template. In Xtend this is called a Rich String and has the following syntax:<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://3.bp.blogspot.com/-27K49EC2dHU/VEqaoYt3luI/AAAAAAAAO-g/2fFOyg-S02w/s1600/greet.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-27K49EC2dHU/VEqaoYt3luI/AAAAAAAAO-g/2fFOyg-S02w/s1600/greet.PNG" height="61" width="200" /></a></div><br />But Xtend doesn't just have placeholders. You can have loops and branches right inside your templates. In other languages you need to go back to the StringBuilder pattern to do that.<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://3.bp.blogspot.com/-x13ObXYnyaM/VEqaq6KOsjI/AAAAAAAAO-o/FLx3p1WSoRM/s1600/html.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-x13ObXYnyaM/VEqaq6KOsjI/AAAAAAAAO-o/FLx3p1WSoRM/s1600/html.PNG" height="225" width="320" /></a></div><br />Notice the different coloring in the whitespace above? Some of it is white, while other pieces are grey. This is how Xtend solves the classic "indentation problem". In &nbsp;most other languages, either your template looks nicely formatted and the generated code is ugly or the other way round. But Xtend is clever enough to notice the difference between indentation in the generated code ("greyspace") and indentation that is just there to make the template look nice ("whitespace").<br /><div><br />Template expressions will come in handy later on when we build Active Annotations to teach the Xtend compiler new tricks. Stay tuned for that!<br /><br /></div><div><h3>Dynamic Dispatch</h3><div><br />Just like Java, Xtend does static dispatch by default. If you have overloaded methods, the argument types known at compile time decide which is chosen. But sometimes you want to defer that decision to runtime. For instance, you might want to build a method that can convert different things to a Date. You pass in on Object and it tries its best to parse it. Possible valid inputs could be Date, Calendar, String, Long, etc.<br /><br />To implement that in Java, you have to create a big if-else cascade to check the runtime types of the argument and then call the appropriate method.<br /><br /><div class="separator" style="clear: both; text-align: left;"></div><div class="separator" style="clear: both; text-align: left;"></div><div class="separator" style="clear: both; text-align: left;"><a href="http://3.bp.blogspot.com/-ip197cHKn78/VEqhxHM84BI/AAAAAAAAO_g/MVKw2kVtLyQ/s1600/dateablejava.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-ip197cHKn78/VEqhxHM84BI/AAAAAAAAO_g/MVKw2kVtLyQ/s1600/dateablejava.PNG" height="400" width="303" /></a></div><br />Also, you have to be careful to put subtypes before supertypes so you don't end up with dead branches.<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://1.bp.blogspot.com/-qmVcgLFVUd8/VEqejIsLEAI/AAAAAAAAO_Q/VvjKO64vGgM/s1600/dateablejavaerror.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-qmVcgLFVUd8/VEqejIsLEAI/AAAAAAAAO_Q/VvjKO64vGgM/s1600/dateablejavaerror.PNG" height="115" width="320" /></a></div><br /><div class="separator" style="clear: both; text-align: left;"></div>Xtend makes dynamic <b><span style="color: purple;">dispatch</span></b> a first class concept. You just write down the different cases. Xtend then looks for the common supertype of the argument types. In this case it's java.lang.Object. Using that argument type, it generates the entry point method similar to what we did by hand in Java. This even works when subclasses add additional overloads. Also notice how we got rid of all the casts that the Java version had.</div><div><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://3.bp.blogspot.com/-G1iE2-MlJDs/VEqa1O98iTI/AAAAAAAAO_A/RulwOqojYns/s1600/dateablextend.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-G1iE2-MlJDs/VEqa1O98iTI/AAAAAAAAO_A/RulwOqojYns/s1600/dateablextend.PNG" height="184" width="320" /></a></div><br />The toDate method was only a simple example to introduce the concept. Dispatch methods really shine when you build code generators, interpreters and other kinds of object tree visitors. Most of the time you don't know the exact type of the elements in that tree at compile time. With dispatch methods, you don't need to care, the correct method will be selected at runtime.</div></div>