---
layout: post
title: Batch processing with myBatis
date: '2011-11-01T21:43:00.000+01:00'
author: Stefan Oehme
tags: 
modified_time: '2011-11-01T21:43:25.909+01:00'
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-5534638240639008143
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2011/11/batch-processing-with-mybatis.html
---

I'm currently working on a clearing application for a big german bank. It's the kind of system where you get hundreds of thousands or even millions of data sets per day and have to process them over night. For this kind of problem. you cannot just load all the data into memory. It may work for the moment, but what if the bank acquires new businesses and the data load suddenly explodes? That's not something you can compensate with hardware.<br />Luckily, there is no reason to hold the whole result set in memory. Clearing usually involves some preprocessing on a per-transaction basis and computing lots of sums after that. For this you don't need more than one data set in memory at any given time. This is where myBatis' custom ResultHandlers come into play. The default implementation is to just put each row from the database into a list and return that list to you after the result set is read completely. But you can change this behaviour by supplying your own handler.<br />For our clearing example this would envolve preprocessing each row by itsself and adding some of its values to the sums we're computing. After this is done, we no longer need that row and thus we can let the garbage collector do its business.<br /><br />So here is how one of those batch processings might look:<br /><br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> private class TransactionHandler implements ResultHandler {  <br />  long impotantSum = 0;  <br />  Date clearingDate = new Date();  <br />  SqlSession session;  <br />   <br />  public TransactionHandler(SqlSession session) {  <br />   this.session = session;  <br />  }  <br />   <br />  public void handeResult(ResultContext context) {  <br />    CreditCardTransaction transaction = (CreditCardTransaction)context.getResultObject;  <br />    transaction.setClearingDate(clearingDate);  <br />    session.update(transaction);  <br />   <br />    importantSum += transaction.getAmount();  <br />  }  <br /> }  <br />   <br /> public void doClearing() {  <br />  //assuming you already have the factory somewhere (e.g. in a container)<br />  SqlSession session = factory.openSession();<br />  TransactionHandler handler = new TransactionHandler(session);  <br />  try {  <br />    //the first parameter is the name of the mapped sql statement<br />    //the second are your query parameters like "all transactions whose status is still set to 'New'"<br />   session.select("findTransactionsToClear", queryParameters, handler);  <br />   long sum = handler.importantSum;  <br />   //do something with that sum (probably exporting it to a file)  <br />   //after everything went well, we can commit our changes  <br />   session.commit();  <br />  } catch (RuntimeException e) {  <br />   //if something goes badly wrong, we can rollback the whole clearing run,  <br />   //leaving the system in a consistent state  <br />   logger.error("Clearing failed", e);  <br />   session.rollback()  <br />  } finally {  <br />  session.close();  <br />  }  <br /> }  <br /></code></pre><br />With this approach you can process millions of data sets with constant memory consumption on the Java side of things. Of course, your database will have to cache lots of updates, but that is what it was built and optimized for.<br /><br /><h2>        Handling updates within the result set</h2>There are some subtle problems to consider when processing involves cross-updates between rows from your result set. This happens for instance when you need to find the original transaction for a reversal (A reversal is sent by another bank and means "Whoops, our fault, please give that poor guy his money back").<br />Take the following logic as an example:<br />"When a reversal is found, we need to find its original transaction in the database. Once we have found it, we set its status to 'reversed'".<br />Now there is a small probability that the orginal transaction is being processed in the same clearing run and thus is part of the result set we are iterating over. If it is further down in the result set, it will not "see" that we have reversed it. This can be a problem if its clearing logic depends on that ("Set status to 'processed', unless status already is "reversed'").<br /><br />There are several ways of ensuring that such changes don't get lost like in the example above.<br /><br />1. Use ORDER_BY to sort the data in such a way that there are no forward references, only backward. In our case, this was the best solution. Our domain export assured us that reversals will always arrive at our system at a later time than the original transaction, never at the same time. So we just sorted by incoming timestamp.<br />2. If the number of changes is small, you can just remeber the IDs of the rows you changed. Then for each row, you look up if it was changed and if so, do a select by id on it. This way you will get the most recent state from the database<br />3. Use a Scroll_Sensitive result set with fetch size 1 (both can be set on a per-mapping basis). This solution is extreme. All changes will be visible&nbsp;immediately, so this can be used when 1. and 2. are not possible. But beware, this comes at the cost of major performance degradation. Use this as a last resort only!