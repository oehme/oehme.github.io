---
layout: post
title: Joda Time to JDBC in three hard lessons
date: '2013-11-04T16:48:00.000+01:00'
author: Stefan Oehme
tags: 
modified_time: '2013-11-04T16:48:14.474+01:00'
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-6853255608519683186
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2013/11/joda-time-to-jdbc-in-three-hard-lessons.html
---

Converting from the popular Joda Time library types to JDBC is a common task that is repeated in many libraries and projects. Many times it is done wrong, resulting in all kinds of time related bugs. I walked into this trap myself and would like to settle this once and for all.<br /><br /><h3>First Lesson: Fear the DST!</h3><br />The simplest implementation which you will find in many libraries just uses the default time zone everywhere. This error is even present in Joda Time's own Hibernate integration project.<br /><br /><script src="https://gist.github.com/oehme/7303563.js"></script> This breaks on the transition to DST. By advancing the clock one our, we end up with times that do not exist. For instance <i>new LocalDateTime(2014, 3, 30, 2,0).toDateTime()</i> will crash in CEST, because the clock advances from 01:59 directly to 03:00.<br /><br /><h3>Second Lesson: Calendar.getInstance() is slow!</h3><br />So to work around this, we need to specify a time zone that has no DST. Our best candidate is of course UTC. But when we use UTC for conversion to the Timestamp, we also need to tell the JDBC driver to use UTC. This can be done by an additional Calendar argument.<br /><br /><script src="https://gist.github.com/oehme/7304164.js"></script> At first I used a new Calendar instance each time this method was called, which resulted in pretty bad performance.<br /><br /><h3>Third Lesson: Don't trust vague JavaDoc!</h3><br />So I refactored towards a constant Calendar. I knew that Calendars are not thread safe. But the JavaDoc says that it is only used for specifying the timezone and locale to use. So this implies that the Calendar will not be written to and can thus be shared among threads.<br /><br /><script src="https://gist.github.com/oehme/7304218.js"></script> Well, it turns out that the Oracle SQL driver does use this Calendar for calculations, so you end up with several threads writing the one instance, resulting in garbage data.<br /><br /><h3>Finally - working and fast</h3><div><br />So finally I replaced the shared Calendar with clones. That's much faster than obtaining a new instance, but safe at the same time. I can only recommend you do the same for your converters.</div><div><br /></div><div><script src="https://gist.github.com/oehme/7304237.js"></script> <div><br /></div><div>Special thanks go to Sun for getting us into this mess in the first place through Java's horrible Date/TimeStamp/Calendar API.</div></div>