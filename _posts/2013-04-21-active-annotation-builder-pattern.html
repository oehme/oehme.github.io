---
layout: post
title: ! 'Active Annotation: Builder Pattern'
date: '2013-04-21T08:58:00.000+02:00'
author: Stefan Oehme
tags: 
modified_time: '2013-05-22T19:22:25.482+02:00'
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-811867290977819745
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2013/04/active-annotation-builder-pattern.html
---

The @Data annotation shipped with <a href="http://www.eclipse.org/xtend/">Xtend </a>is a nice demonstration of the concept of active annotations. It generates a constructor, getters for all fields as well as equals(), hashCode() and toString() methods. Although it says that it turns your class into an "immutable value object", this is not really true. For instance, the generated class is not final and thus can have mutable subclasses. Also, it renames fields so that reflection bases frameworks will not find the corresponding field for a given property. Using the big constructor with all fields can be hard to read, especially if multiple fields have the same type.<br /><br />So I wanted something a little different. For bigger objects you just need a builder. This is what my @Immutable annotation does:<br /><ul><li>getters for all fields</li><li>a constructor with all fields</li><li>a builder class with setters for each field of the class</li><li>a static builder() method for fluent building in Java clients</li><li>a static build(Procedure) method for closure-style building in Xtend clients</li><li>equals(), hashCode() and toString() implementations</li><li>makes the class final</li><li>forbids inheriting from other classes</li></ul><div>Here you can see the annotation and the build(Procedure)-method in action.<br /><br /><script src="https://gist.github.com/oehme/5428677.js"></script> In the future I plan to analyze the classes' fields and generate defensive copying of known mutable classes. For instance, if the class contains a Date field, it will automatically be copied in the constructor and the getter. A warning will be issued for all cases where the annotation does not know whether a field is of a mutable type. This warning will be suppressed if the user specifies his own implementation of a public getter and a private setter (used by the constructor).<br /><br />Also, there is a lot of fine tuning to do like not overwriting the toString() method if the user has already specified a custom one.<br /><br />So for everyone who's interested, here is the full implementation of the annotation processor. It's just over a hundred lines of code that saves me thousands of lines of boilerplate in my data classes.<br /><br /><script src="https://gist.github.com/stefan-oehme/5428675.js"></script></div>