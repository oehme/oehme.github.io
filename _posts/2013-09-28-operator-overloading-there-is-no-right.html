---
layout: post
title: ! 'Operator Overloading: There is no "right" choice.'
date: '2013-09-28T16:59:00.001+02:00'
author: Stefan Oehme
tags: 
modified_time: '2013-09-28T16:59:47.642+02:00'
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-5190028535924865955
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2013/09/operator-overloading-there-is-no-right.html
---

I've been looking into <a href="http://www.eclipse.org/xtend/">Xtend </a>a lot lately, but I do not limit myself to one language. In fact, I've had an eye on all of the major competitors in the JVM language market. One thing that sparks many religious debates among the different communities is operator overloading. It's not just "whether" it should be allowed, but also "how". There are now four different approaches on the market and I will give you the pros and cons of each one without the usual fanboyism.<br /><br /><h3>Java: No operator overloading</h3><br />Without any operator overloading at all, you are stuck with what the core language provides. A very simple and annoying example of this is java.math.BigDecimal. Because there is no "+" operator for BigDecimal, you always have to write x.plus(y). Of course, this gets out of hand quickly. "(x + y) * z" becomes x.plus(y).multiply(z). On the other hand, when you see a "+" operator, you know exactly what it means and you can also deduct that the types to either side of the operator must be one of the primitive number types. But all in all, readability suffers greatly, especially with custom numeric types.<br /><br /><h3>Xtend: Freely overloading predefined operators</h3><br />In Xtend, you can freely overload any of the predefined operators. There is no restriction on the argument and return types. This is useful for writing internal DSLs. By adding operator overloading to the already awesome QueryDSL, the following Xtend code looks pretty close to an SQL where-clause:<br /><br /><script src="https://gist.github.com/oehme/6087325.js"></script> The "==" operator does not compare two objects in memory, as it would do normally. It does not return "true" or "false". Instead it returns a "Predicate" which can then be transformed into an SQL query that is then executed against the database.<br /><br />On the other hand, you can do all kinds of weird stuff with free overloading. When you see "x + y" in Xtend, it could mean literally anything. I could override "+" to make it add the length of two Strings instead of concatenating them. And sadly, many developers tend to go overboard like this. They come up with new meanings that have not much to do with the original use of the operator in question.<br /><br /><h3>Scala: Do whatever you want</h3><br />In <a href="http://www.scala-lang.org/">Scala </a>you can not only override existing operators, but you can define pretty much any operator you want. So if you want to emulate SQL syntax and you want the "&lt;&gt;" ("not equal") operator, you can just define it. In Xtend you would have to use the existing "!=" operator, which is probably just as understandable, but not exactly like in SQL. As a bonus, you can use infix notation for any binary function in Scala. So you can write "x IN (1, 2, 3)" like in SQL instead of "x.in(1, 2, 3)". It's a small difference but it quickly adds up as you can see in the following example taken from <a href="http://www.jooq.org/doc/2.6/manual/getting-started/jooq-and-scala/">jOOQ</a>:<br /><br /><script src="https://gist.github.com/oehme/6742828.js"></script> On the other hand, things can get even more out of hand. Would you know what "x =#!&gt; y" means? Any library author can come up with as many new operators as they want. And oh boy do they abuse this!<br /><br /><h3>Ceylon: Operator Polymorphism</h3><br /><a href="http://ceylon-lang.org/">Ceylon </a>is the new kid on the block and brings a fresh idea: Operators that are bound to interfaces. If you want your class to be usable with the "+" operator, you need to implement the "Summable" interface and its "plus" method. The "plus" method has a strict signature, so it will always take two things of the same type and return a result of the same type. This means you cannot create something like the QueryDSL and JOOQ examples I showed above. On the other hand, there is very little ambiguity as to what "x+y" means, no matter which code base you are just reading. This kind of discoverability is very important in big and long-lived code bases where the original authors my not even be around anymore.<br /><br /><h3>Conclusion</h3><br />In the end, I think only Java really falls short with its "no overloading at all" policy. All the other approaches have their merit. It all depends on the kind of project and team you have. The worst programmers are those who are intelligent enough to grasp the language concepts, but not smart enough to apply them only where appropriate. They seem to think that in order to master the language, they need to push it to its syntactical limits.<br /><br />So if you have the right people writing your libraries, you'll be fine and you will get some awesome internal DSLs. If not, you should use a more restrictive language or you're in for a maintenance nightmare.<br /><br />