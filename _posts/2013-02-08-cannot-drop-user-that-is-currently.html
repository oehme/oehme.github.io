---
layout: post
title: Cannot drop a user that is currently connected
date: '2013-02-08T07:52:00.000+01:00'
author: Stefan Oehme
tags: 
modified_time: '2013-05-22T19:24:11.193+02:00'
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-83643555610653509
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2013/02/cannot-drop-user-that-is-currently.html
---

I hate this message. It constantly broke our CI builds. Here is why and how I fixed it.<br /><br /><h2>The Basic Setup</h2><div>We use Maven as our build system. In UI projects we start a Jetty server that hosts our application and run a bunch of frontend tests against it. Our application also needs an Oracle database so we setup and tear down this as well. The build phases go like this:</div><div><br /></div><div>pre-integration-test:&nbsp;</div><div>- create database user (== schema in Oracle)</div><div>- update database with the latest scripts</div><div>- jetty:start (daemon mode)</div><div><br /></div><div>integration-test:</div><div>- failsafe plugin runs tests</div><div><br /></div><div>post-integration-test:</div><div>- jetty:stop</div><div>- drop database user<br /><br /><h2>The Problem</h2></div><div>The problem comes with the post-integration-test phase. The jetty:stop command returns immediately while the server is busy shutting down. All the while our drop script tries to "Drop user @username cascade;" and fails with the error that gave this post its title. So our first reaction was to write our own little Jetty plugin that actually waits for a complete server shutdown. This worked, but it made builds unnecessarily slow.</div><div><br /></div><h2>The Solution</h2><div>So I took another go at our drop script and changed it to this:</div><div><br /></div><div><script src="https://gist.github.com/oehme/4737130.js"></script></div><div><br /></div><div>With this script in place we could now shut down Jetty and drop the Oracle user in parallel, making our builds that much faster.&nbsp;</div><div><br /></div><div>As a bonus I stumbled across another Oracle oddity: Our users have dedicated tablespaces (named "&lt;username&gt;_&lt;tablespacename&gt;"), so we drop them too. Since we already did a cascading drop of the user, we can be sure that those tablespaces are empty. You would think that Oracle recognizes this, but at least on 11gR2 you would be wrong. Calling "drop tablespace @tablespacename including contents" is much slower than "drop tablespace @tablespacename" even if the tablespace is empty. This spares us some more valuable seconds in each build.</div>