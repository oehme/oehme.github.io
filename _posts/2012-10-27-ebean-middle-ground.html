---
layout: post
title: Ebean - A middle ground
date: '2012-10-27T13:21:00.000+02:00'
author: Stefan Oehme
tags: 
modified_time: '2012-10-27T13:21:06.197+02:00'
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-6524757837440379265
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2012/10/ebean-middle-ground.html
---

<h3>The usual problem</h3><div><br /></div>So you have this <a href="http://martinfowler.com/eaaCatalog/domainModel.html">rich domain model</a> and you're wondering how to get it in and out of your database. Of course I could just tell you to "use an object oriented DB and be done with it", but let's assume that you are somehow required to use a relational store.<br /><br /><h3>Hibernate?</h3><div><br /></div><a href="http://www.hibernate.org/">Hibernate </a>and other full-blown JPA implementations can be a bit overkill due to the amount of "magic" going on in the background. They take a lot of work off your shoulders. But if anything goes wrong, you often spend a large amount of time debugging (two words: lazy loading).<br /><br /><h3>Mybatis?</h3><div><br /></div>When looking for alternatives, many people - me included - often recommend <a href="http://code.google.com/p/mybatis/">Mybatis</a>. Mybatis is radically simple in its concept, being just a thin wrapper on top of JDBC. It is great for mapping even the most complicated queries. This makes it especially suited for working with legacy databases out of your control or for batch processing and business intelligence queries.<br /><br />However, Mybatis is not an ORM. It does not know your objects. It just knows SQL queries. So when you select the same thing with two different queries, you will get two different instances. This makes handling complex object relationships very involved. Also, since Mybatis does not keep track of you objects, saving changes becomes an even greater&nbsp;challenge&nbsp; Things like cascading persist just don't exist. So if you were to load and persist complex object trees, you would need to implement a lot of ORM logic on top of Mybatis.<br /><br /><h3>Ebean!</h3><div><br /></div><h4>The concept</h4>But there is a middle ground. It is called <a href="http://www.avaje.org/">Ebean</a>. Ebean reads JPA annotations, but does not implement JPA itself. It has a much simpler model. Ebean has a persistence context that guarantees object identity within transactions. But it does not "automagically" synchronize changes between memory and the database. You need to&nbsp;explicitly&nbsp;call "save" to persist changes to an object. You could view this as objects always being "detached". This is not entirely true, because with Ebean your objects keep track of changes themselves, so they are somewhere between what JPA calls "Managed" and "Detached". This makes reasoning about a program a lot simpler.<br /><br /><h4>Features</h4>Ebean comes with nice criteria queries that support automatic join fetching. So if you ask for all employees who work in the "IT" department, you can write something like "eq("department.name", "IT")" and Ebean will know that it has to join the employee table and the department table to find the correct answer. You can also specify fetch strategies on a per-query basis. So if you have two different use cases, one where you always need a certain association and one where you don't need it, you can write two different queries, resulting in optimized&nbsp;performance&nbsp; Lazy loading just works, as Ebean can keep connections open after a transaction has finished in order to lazily load more data.<br /><br />Ebean also has nice support for raw SQL, similar to what Mybatis can do, just a little less flexible. You can write classes that represent the result of a SQL query (like some aggregation result) and tell Ebean how to map the result set to the bean's fields. Batch processing is also supported in two ways. RawSQL objects never get attached to the persistence context, so they don't eat up your memory. And if you want to batch process Entities, you can use a visitor-like query that executes a callback for every entity found, but does not put those entities into the persistence context.<br /><br />The configuration of Ebean is very pluggable, so you can change datasources, transaction management, naming conventions and a lot more. The source code is also neatly structured. So if you find something lacking, it is pretty easy to find the correct place for you enhancement. I was able to add a naming convention for embeddable objects (so you don't need @AttributeOverride so often) in about 5 lines of code.<br /><br /><h4>Limitations</h4>The downside of Ebean is its currently very small development team. As far as I know, there are only 3 active commiters. So bug fixes are kind of slow and new features take even longer. Ebean still does not support all of JPA 1's annotations and JPA 2 is still a long way to go. Especially the inheritance implementation still suffers from subtle bugs. But since I like the basic concepts of Ebean so much, I would like to see more people using and maybe even contributing to it. Just give it a try and share your&nbsp;experiences&nbsp;in the <a href="https://groups.google.com/forum/?fromgroups#!forum/ebean">google group</a>.