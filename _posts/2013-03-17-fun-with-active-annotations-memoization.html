---
layout: post
title: ! 'Fun with Active Annotations: Memoization'
date: '2013-03-17T11:53:00.000+01:00'
author: Stefan Oehme
tags: 
modified_time: '2013-05-22T19:23:58.484+02:00'
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-4500215677401818390
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2013/03/fun-with-active-annotations-memoization.html
---

With the next release of <a href="http://www.eclipse.org/xtend/">Xtend </a>only 3 days away, I did some experimenting with the latest language feature: active annotations. In short, active annotations allow you to participate in the Xtend-to-Java compilation process, altering the AST or even generating whole new classes and resources. But not only that: Any change you make is automatically visible in content assist, the outline view, navigation etc. Plus, you can add errors and warnings to the Xtend source.<br /><br />My first idea was to build an annotation that can memoize any method. Memoization means remembering the return value for given parameters and returning this cached value when the method is called again with the same parameters. This is useful for expensive calculations and recursive algorithms.<br /><br />So I want this Xtend code<br /><br /><script src="https://gist.github.com/oehme/5180879.js"></script> to compile into this Java code<br /><br /><script src="https://gist.github.com/oehme/5180925.js"></script> This is done by the following annotation processor. It has different handling for 0, 1 and multiple parameters to optimize performance.<br /><br /><script src="https://gist.github.com/oehme/5180927.js"></script> As you can see, the body of the method is replaced with a call to a cache. The cache is populated with values from an initializer method that has the body of the original method. For methods without parameters, I just use double null check synchronization. For everything else there is <a href="https://code.google.com/p/guava-libraries/wiki/CachesExplained">Guava's wonderful LoadingCache</a>. For methods with one parameter, the cache key is the type of the single paramter. For methods with multiple paramters, I added a small helper class that holds an array of parameters and provides an equals and hashcode method. Some of the finer points like exception handling, method overloading and primitive types are also handled by the annotation processor in order to generate production quality code.<br /><br />This could be further expanded with expiration strategies and other options defined in the annotation. But for now, I'm pretty pleased with the results. Getting the 40th fibonacci number takes only 1 millisecond on my laptop. Without memoization, this goes up to 5 full seconds.<br /><br />