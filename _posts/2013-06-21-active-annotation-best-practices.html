---
layout: post
title: Active Annotation best practices
date: '2013-06-21T14:59:00.002+02:00'
author: Stefan Oehme
tags: 
modified_time: '2013-06-21T14:59:37.480+02:00'
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-2988740054185426334
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2013/06/active-annotation-best-practices.html
---

I recently gave a talk about <a href="http://www.eclipse.org/xtend/documentation.html#activeAnnotations">Active Annotations</a> at the Eclipse demo camp in Dresden. One of the first questions that came up was "This is pretty advanced stuff, do you have any best practices?". After writing a bunch of Active Annotations for the <a href="https://github.com/oehme/xtend-contrib">xtend-contrib</a> library, I actually have a couple of recommendations I'd like to share.<br /><br /><h3>Start with examples, but then write tests</h3><div><br /></div><div>When you write an Active Annotation, you will want quick feedback at first. So create an example project and write a small class that uses your annotation. Open the generated Java code of that class side by side with your annotation processor and see whether you are on the right track.</div><div><br /></div><div>Once you are confident in the functionality however, it's time to write tests. Examples will only bring you so far and they always need to be in a different project. But you want test cases to be run in the same project that compiles your annotation processor. There is a <a href="http://www.eclipse.org/xtend/documentation.html#active_annotation_classpath">section on testing</a> active annotations in the Xtend Tutorial. I tend to use <a href="http://jnario.org/">JNario </a>and break down my tests into lots of little facts about the generated code. For an example, just look at the specification of the <a href="https://github.com/oehme/xtend-contrib/blob/master/base/src/test/java/de/oehme/xtend/contrib/base/Cached.spec">@Cached</a> annotation.</div><div><br /></div><h3>Do not rename things</h3><div><br /></div>This is probably the most important advice. Renaming things will break reflection based frameworks and other annotation processors that come after you.<br /><br />Sadly, the two annotations shipped with Xtend, @Property and @Data, do just that. If you have a field called "firstName", they will generate an accessor method called "getFirstName", but the field will be renamed to "_firstName". This breaks frameworks like JAXB or Bean Validation. It also makes the code less clear because you define a field and then access it under a different name. Never do this!<br /><br />The more advanced problem is composability. If there are several annotation processors on a class and the first one renames a couple of fields, then the subsequent processor will produce bogus results.<br /><h3><div style="font-size: medium; font-weight: normal;"><br /></div></h3><h3>Don't overwrite handwritten code</h3><div><br /></div><div>This is a more advanced technique that will make your users smile. Let's say your &nbsp;annotation can automatically generate a toString() method for a class. This is nice, but sometimes users will have an implementation that prints something more meaningful than your default implementation. If you just blindly add the toString() method, then they will get a "duplicate method" exception when trying to override it. So check if there already is a toString() method and only if there isn't you may add your default one.</div><div><br /></div><div>xtend-contrib-base has<a href="https://github.com/oehme/xtend-contrib/blob/master/base/src/main/java/de/oehme/xtend/contrib/base/ASTExtensions.xtend"> utility methods</a> that allow you to easily find out whether a class already has a certain method. Plus, there are<a href="https://github.com/oehme/xtend-contrib/blob/master/base/src/main/java/de/oehme/xtend/contrib/base/CommonTransformations.xtend"> convenient shortcuts</a> for commonly used methods like equals, hashCode and toString.</div><div><br /></div><h3>Extract commonly used transformations</h3><div><br /></div><div>There are transformations that occur over and over again. For instance, you may want to implement a method from a given interface. This is pretty much always the same, copying the signature from the interface and then adding a body.</div><div><br /></div><div>Other common transformations are:&nbsp;</div><div><ul><li>adding a toString() method that uses all persistent fields</li><li>adding a hashCode() method&nbsp;that uses all persistent fields</li><li>adding an equals() method&nbsp;that uses all persistent fields</li><li>adding a constructor that takes an argument for each persistent field</li><li>wrapping a method (see below)</li></ul><div>Move these out into a helper class so you don't introduce copy-paste errors. xtend-contrib-base has methods for all the cases described above and more.</div></div><div><br /></div><h3>Pattern: Wrapping a method</h3><div><br /></div><div>Many method level annotations want to add some behavior around the actual body of the original method. This can be achieved as follows:</div><div><ol><li>Add a new private method with exactly the same signature as the original one and give it a special name</li><li>Move the body of the original method to the new private method</li><li>Replace the body of the original method with a call to the new method, adding behavior before and after as needed</li></ol><div>In future Xtend versions, you will be able to just alter the body itself and add statements to it. But as of now, the pattern described above works very well. Of course, xtend-contrib-base has a convenient function that will do just that for you. All you have to specify are the name of the inner method and the new body of the outer method.</div></div><div><br /></div><h3>Design for composition or document bad composability</h3><div><br /></div><div>Active Annotations deeply manipulate the AST of a class. This makes them pretty hard to combine, as one annotation might stumble over changes that another has already made. If you want to make your annotation as composable as possible you need to think hard about how you can avoid interference with other ones.&nbsp;</div><div><br /></div><div>The "do not rename things" advice is one of the most important steps. But you also need to think about whether you want to process members that other annotations have generated before you or if you want to ignore them. It depends on the semantics of your annotation. The TransformationContext has an "isGenerated" method that will tell you whether something was created by another active annotation.</div><div><br /></div><div>If you are having a hard time getting this right, don't feel bad. It's already hard in relatively simple cases and almost impossible for complex annotations. In that case, just document the fact that your annotation is not safe to use with others.</div><div><br /></div><h3>Add helpful error messages</h3><div><br /></div><div>If your annotation cannot do its job, do not just fail with NullPointer- or ClassCastExceptions. Add helpful error messages to the offending points in the code. This will help your users learn how to use your annotation much faster.&nbsp;</div><div><br /></div><h3>Make it quick</h3><div><br /></div><div>Your annotation processor will be run on each incremental compiler run. This means each time the user types something! It needs to be fast or your users will be put off. So avoid I/O and other heavyweight tasks as much as possible!</div><div><br /></div><div>One idea I often hear is generating DDL. Don't do this with active annotations!</div><div><br /></div><div>First off, you probably do not need your "Create Table" statements to be up to date on each change to a source file. Second, there are existing tools for that. Third, even if no tool suits your need, you should just use runtime reflection to collect the data from your compiled classes and then generate the DDL from that. This makes the generator much easier (the active annotation API is pretty low level!). Plus, you can run it as a separate, one-time build step after compilation. So instead of directly generating SQL files, just add the mapping annotations to your classes and then use existing tools from there.</div><div><br /></div><h3>If it can be done with a framework, use it</h3><div><br /></div><div>A last word of caution: Active annotations are cool, but there are many problems that can be solved by using a framework. They are usually much more composable than class manipulation, so leave active annotations for cases where you actually want to see and directly call the generated code.&nbsp;</div><div><br /></div><div>ORM is a good counter-example here. You don't want to see the synthetic methods that take care of lazy loading, dirty checking etc. Those are implementation details that best stay hidden. If one of your frameworks forces you to write lots of boilerplate, be sure to look for better frameworks before writing a boilerplate-generating annotation.</div>