---
layout: post
title: Xtend - Active Annotations Part 1
date: '2014-11-02T13:00:00.000+01:00'
author: Stefan Oehme
tags:
- xtend series
modified_time: '2014-11-26T17:50:12.528+01:00'
thumbnail: http://2.bp.blogspot.com/-MPqNxaUaVQw/VFYXT2Cb8NI/AAAAAAAAPBQ/LFnicy1a0cQ/s72-c/Boring.PNG
blogger_id: tag:blogger.com,1999:blog-7973028861743150658.post-6770105332110725497
blogger_orig_url: http://mnmlst-dvlpr.blogspot.com/2014/11/xtend-active-annotations-part-1.html
---

There are many patterns in Java-land that make you feel like a robot. You write Accessors, Delegates, ValueObjects, ViewModels, XML bindings and many others. There is no real logic in this kind of code. You usually just copy-paste it or have your IDE auto-insert it. But all that boilerplate is still there and distracts the eye from the real logic of your program. And it is also easy to overlook a simple copy-paste error.<br /><br />This is where Active Annotations come into play. They allow you to participate in the translation from Xtend to Java code. You can do everything from adding simple methods to creating completely new classes or generating arbitrary resources. And the IDE knows what you are doing at all times, giving you the navigation, validation and auto completion that your are used to with hand-written code.<br /><br />The Xtend library ships with a few Active Annotations out of the box. Let's have a look at these first to get a basic idea of what they are all about.<br /><br /><h4>@Data</h4><br />Remember our Complex number example? We wanted an immutable datatype with two double values. Now normally we would have to write a constructor, getters, equals/hashCode and toString for that.<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://2.bp.blogspot.com/-MPqNxaUaVQw/VFYXT2Cb8NI/AAAAAAAAPBQ/LFnicy1a0cQ/s1600/Boring.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-MPqNxaUaVQw/VFYXT2Cb8NI/AAAAAAAAPBQ/LFnicy1a0cQ/s1600/Boring.PNG" height="400" width="326" /></a></div><br />But there is an annotation that does exactly that. Just annotate the class with @Data and all the boilerplate is generated for you. Now you can focus on the interesting math. Neat, huh? ;)<br /><br /><div class="separator" style="clear: both; text-align: left;"></div><div class="separator" style="clear: both; text-align: left;"><a href="http://1.bp.blogspot.com/-t8bCV966Awg/VFYZCS96ydI/AAAAAAAAPCM/NRzlVuiEAQc/s1600/Better.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-t8bCV966Awg/VFYZCS96ydI/AAAAAAAAPCM/NRzlVuiEAQc/s1600/Better.PNG" height="80" width="200" /></a></div><br /><br />When you switch the outline view into "JVM mode" you will also see all the generated members in grey. You can click on getters in the outline and are taken to the corresponding field and vice versa.<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://3.bp.blogspot.com/-OZJH4TlV5ec/VFYXcGWI5bI/AAAAAAAAPBg/scup5M_xxgo/s1600/Outline.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-OZJH4TlV5ec/VFYXcGWI5bI/AAAAAAAAPBg/scup5M_xxgo/s1600/Outline.PNG" height="220" width="320" /></a></div><br />The generated methods and constructors are also proposed in content assist. The IDE experience is the same as if you had written them yourself. If you are curious, you can open up the generated Java file to assure yourself that the annotation does exactly what you expect.<br /><br /><h4>@Accessors</h4><br />Another common pattern are getters and setters. When you annotated a field with @Accessors, a getter and setter will be generated for you. If you put the annotation on a class, there will be getters and setters for all fields. If there are final fields, then there will be no setter for them of course. Instead there will be a constructor that takes those final fields.<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://2.bp.blogspot.com/-6HJmC1T-5pk/VFYXfRDYvBI/AAAAAAAAPBo/gEiNv4Lgjmc/s1600/accessors.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-6HJmC1T-5pk/VFYXfRDYvBI/AAAAAAAAPBo/gEiNv4Lgjmc/s1600/accessors.PNG" height="102" width="200" /></a></div><br />Want to have getters only? Or protected setters? Or exclude one field completely? No problem, just use the AccessorType value inside the @Accessors annotation.<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://3.bp.blogspot.com/-YOWO9OBicAg/VFYXh1kwmiI/AAAAAAAAPBw/5vKNJQz5QOY/s1600/accessors_customization.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-YOWO9OBicAg/VFYXh1kwmiI/AAAAAAAAPBw/5vKNJQz5QOY/s1600/accessors_customization.PNG" height="62" width="200" /></a></div><div class="separator" style="clear: both; text-align: left;"><br /></div><h4>@Delegate</h4><br />Quite often you want to implement an interface, reusing 95% of an existing implementation and only changing a few methods. That's exactly what @Delegate allows you to do. Just annotate a field or method with @Delegate.<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://4.bp.blogspot.com/-lziIOx_-yrc/VFYXoJBzafI/AAAAAAAAPB4/jgeeioVHIkY/s1600/delegate.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-lziIOx_-yrc/VFYXoJBzafI/AAAAAAAAPB4/jgeeioVHIkY/s1600/delegate.PNG" height="111" width="320" /></a></div><br />Any interfaces that your class and the delegate object share will get default implementations that just forward the call to the delegate object. You can restrict the interfaces you want to have implemented by listing them inside the annotation.<br /><br /><h4>@FinalFieldsConstructor, @EqualsHashCode, @ToString</h4><br />These are basically the parts that make up @Data. We broke them out for two reasons. First of all because they are useful on their own. Secondly because you can use them to customize the behavior of @Data.<br /><br />Let's say you don't like the default toString method and want a more concise representation. Just add <i>@ToString(hideFieldNames = true, singleLine = true)</i><br /><i><br /></i>Or maybe your final-fields-constructor needs some additional annotations. Just write an empty constructor and annotate it with @FinalFieldsConstructor. The annotation will insert the boring parameters and body for you.<br /><br /><div class="separator" style="clear: both; text-align: left;"><a href="http://3.bp.blogspot.com/-uSn6xZ9Sxas/VFYXwEfXxmI/AAAAAAAAPCA/pd2BnoMR-9I/s1600/finalfieldsconstructor.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-uSn6xZ9Sxas/VFYXwEfXxmI/AAAAAAAAPCA/pd2BnoMR-9I/s1600/finalfieldsconstructor.PNG" height="110" width="200" /></a></div><br /><br />These annotations alone are a good reason to like Xtend. But the real killer feature is that you can easily write your own. Get ready to automate the hell out of your projects! =)